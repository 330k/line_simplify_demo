<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GPS Track Line Simplification Algorithms Comparison</title>
<meta property="og:title" content="GPS Track Simplification Comparison Demo" />
<meta property="og:description" content="Demonstration of Line Simplification Algorithms for GPS Tracks" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://330k.github.io/line_simplify_demo/gpx_visual_simplify.html" />
<meta property="og:image" content="https://www.330k.info/apple-touch-icon.png"/>
<!--<meta name="viewport" content="width=device-width,initial-scale=1">-->
<meta name="viewport" content="width=640px,initial-scale=1">
<script defer src="https://maps.google.com/maps/api/js?key=AIzaSyA_aFkNjCuqBNETe8bxBk8_cnRQtQzdOG8&amp;callback=initMap"></script>
<script>
let googlemap;
const loaded_lines = [];
const reduced_lines = new Map();
const reduce_algorithms = [
  { checkbox_id: "checkbox_douglaspeucker",    name: "Douglas-Peucker",     func: douglasPeucker,    color: "#f00", zindex: 990, checked: "checked" },
  //{ checkbox_id: "checkbox_douglaspeucker3d",  name: "Douglas-Peucker(3D)", func: douglasPeucker3D,  color: "#800", zindex: 980, checked: "checked" },
  { checkbox_id: "checkbox_visvalingamwhyatt", name: "Visvalingam-Whyatt",  func: visvalingamWhyatt, color: "#00f", zindex: 890, checked: "checked" },
  //{ checkbox_id: "checkbox_visvalingamwhyatt3d", name: "Visvalingam-Whyatt(3D)",  func: visvalingamWhyatt, color: "#008", zindex: 680, checked: "checked" },
  { checkbox_id: "checkbox_raumannwitkam",     name: "Reumann-Witkam",      func: ReumannWitkam,     color: "#ff0", zindex: 790, checked: "checked" },
  { checkbox_id: "checkbox_lang",              name: "Lang",                func: Lang,              color: "#f80", zindex: 690, checked: "" },
  { checkbox_id: "checkbox_crosstrack",        name: "Cross-Track",         func: crossTrack,        color: "#0f0", zindex: 590, checked: "" },
  //{ checkbox_id: "checkbox_crosstrack3d",      name: "Cross-Track(3D)",     func: crossTrack,        color: "#080", zindex: 680, checked: "" },
  { checkbox_id: "checkbox_arclength",         name: "Arc-Length",          func: arcLength,         color: "#0ff", zindex: 590, checked: "" },
  //{ checkbox_id: "checkbox_arclengthg",        name: "Arc-Length(G)",       func: arcLengthG,        color: "#0aa", zindex: 580, checked: "" },
  { checkbox_id: "checkbox_kashmir3d",         name: "Kashmir3D Emulate",   func: kashmir3D,         color: "#f0f", zindex: 290, checked: "" },
  { checkbox_id: "checkbox_nthpoint",          name: "Nth-Point",           func: nthPoint,          color: "#008", zindex: 190, checked: "" },
];

Promise.all([new Promise(function(resolve, reject){
  window.initMap_resolve = resolve;
})]).then(() => {
  hideLoader();
});

/**
 * Google Maps JavaScript API Initialize Callback
 */
function initMap(){
  googlemap = new GoogleMapManager(document.getElementById("map_canvas"));
  
  window.initMap_resolve();
}

/**
 * Hubeny測地線距離計算式
 * @param {number} lat1
 * @param {number} lon1
 * @param {number} lat2
 * @param {number} lon2
 * @return {number} distance [m]
 */
const hubeny = (function(){
  const a = 6378137.0;
  const f = 1 / 298.257223563;
  const e2 = f * (2 - f);
  const degree = Math.PI / 180.0;
  const sin = Math.sin;
  const cos = Math.cos;
  const sqrt = Math.sqrt;
  return function (lat1, lon1, lat2, lon2){
    const latdiff = (lat1 - lat2) * degree;
    const londiff = (((lon1 - lon2 + 180) % 360) - 180) * degree;
    const latave = 0.5 * (lat1 + lat2) * degree;
    const sinlatave = sin(latave);
    const coslatave = cos(latave);
    const w2 = 1.0 - sinlatave * sinlatave * e2;
    const w = sqrt(w2);
    const meridian = a * (1 - e2) / (w2 * w);
    const n = a / w;

    return sqrt(
      latdiff * latdiff * meridian * meridian +
      londiff * londiff * n * n * coslatave * coslatave
    );
  };
})();
/**
 * Hubeny測地線距離計算式(標準)
 * https://amano-tec.com/apps/paceruler.html
 * @param {number} lat1
 * @param {number} lng1
 * @param {number} lat2
 * @param {number} lng2
 * @return {number} distance [m]
 */
function hubeny4(lat1, lng1, lat2, lng2){
  "use strict";
  const a = 6378137.0;
  const f = 1 / 298.257223563;
  const e2 = f * (2 - f);
  const e2p = e2 / (1 - e2);
  const degree = Math.PI / 180.0;
  const sin = Math.sin;
  const cos = Math.cos;
  const tan = Math.tan;
  const sqrt = Math.sqrt;
  
  const latdiff = (lat1 - lat2) * degree;
  const lngdiff = (((lng1 - lng2 + 180) % 360) - 180) * degree;
  const latave = 0.5 * (lat1 + lat2) * degree;
  const sinlatave = sin(latave);
  const coslatave = cos(latave);
  const w2 = 1.0 - sinlatave * sinlatave * e2;
  const n = a / sqrt(w2);
  const eta2 = e2p * coslatave * coslatave;
  const eta4 = eta2 * eta2;
  const eta6 = eta2 * eta4;
  const t = tan(latave);
  const t2 = t * t;
  const t4 = t2 * t2;
  const t6 = t2 * t4;
  const latdiff2 = latdiff * latdiff;
  const latdiff3 = latdiff * latdiff2;
  const latdiff4 = latdiff * latdiff3;
  const latdiff5 = latdiff * latdiff4;
  const latdiff6 = latdiff * latdiff5;
  const lngdiff2 = lngdiff * lngdiff;
  const lngdiff3 = lngdiff * lngdiff2;
  const lngdiff4 = lngdiff * lngdiff3;
  const lngdiff5 = lngdiff * lngdiff4;
  const lngdiff6 = lngdiff * lngdiff5;
  const lngdiff7 = lngdiff * lngdiff6;
  const coslatave2 = coslatave * coslatave;
  const coslatave3 = coslatave * coslatave2;
  const coslatave4 = coslatave * coslatave3;
  const coslatave5 = coslatave * coslatave4;
  const coslatave6 = coslatave * coslatave5;
  const coslatave7 = coslatave * coslatave6;

  const ss = n * coslatave * lngdiff
    + (n * coslatave  /      24) * (1 - eta2 + eta4 - eta6 - 9 * t2 * eta2 + 18 * t2 * eta4 - 27 * t2 * eta6) * latdiff2 * lngdiff
    + (n * coslatave3 /      24) * (-t2) * lngdiff3
    + (n * coslatave  /    5760) * (7 + 10 * eta2 - 27 * eta4 - 54 * t2 * eta2 - 642 * t2 * eta4 + 675 * t2 * eta6) * latdiff4 * lngdiff
    + (n * coslatave3 /    5760) * (-16 - 70 * t2 - 158 * t2 * eta2 + 158 * t2 * eta4 + 90 * t4 * eta2 - 180 * t4 * eta4) * latdiff2 * lngdiff3
    + (n * coslatave5 /    5760) * (-24 * t2 + 3 * t4 - 27 * t2 * eta2) * lngdiff5
    + (n * coslatave  / 1935360) * 62 * latdiff6 * lngdiff
    + (n * coslatave3 / 1935360) * (-416 - 2954 * t2) * latdiff4 * lngdiff3
    + (n * coslatave5 / 1935360) * (-192 - 1680 * t2 + 2652 * t4) * latdiff2 * lngdiff5
    + (n * coslatave7 / 1935360) * (-816 * t2 + 528 * t4 - 6 * t2) * lngdiff7;
  const sc = n / (1 + eta2) * latdiff
    + (n              /      24) * (3 * eta2 - 6 * eta4 + 9 * eta6 - 3 * t2 * eta2 + 21 * t2 * eta4 - 54 * t2 * eta6) * latdiff3
    + (n * coslatave2 /      24) * (-2 - 3 * t2 + 3 * t2 * eta2 - 3 * t2 * eta4 + 3 * t2 * eta6) * latdiff * lngdiff2
    + (n              /    5760) * (-36 * eta2 + 207 * eta4 + 36 * t2 * eta2 - 1062 * t2 * eta4 + 135 * t4 * eta4) * latdiff5
    + (n * coslatave2 /    5760) * (-16 - 60 * t2 + 4 * eta2 - 4 * eta4 + 102 * t2 * eta2 + 48 * t2 * eta4 + 90 * t4 * eta2 - 630 * t4 * eta4) * latdiff3 * lngdiff2
    + (n * coslatave4 /    5760) * (-8 - 20 * t2 + 15 * t4 - 8 * eta2 + 96 * t2 * eta2 - 15 * t4 * eta2 + 15 * t4 * eta4) * latdiff * lngdiff4
    + (n * coslatave2 / 1935360) * (-192 - 2016 * t2) * latdiff5 * lngdiff2
    + (n * coslatave4 / 1935360) * (256 + 784 * t2 + 4200 * t4) * latdiff3 * lngdiff4
    + (n * coslatave6 / 1935360) * (-64 - 224 * t2 + 1148 * t4 - 42 * t6) * latdiff * lngdiff6;
  return sqrt(ss * ss + sc * sc);
}

/**
 * XMLファイルを読み込むPromiseを返す
 * @param {string} file 読み込むファイル
 * @return {XMLDocument} 読み込んだ結果をXMLObjectを返すPromise
 */
function readXML(file){
  return new Promise(function(resolve, reject){
    try{
      const reader = new FileReader();
      const parser = new DOMParser();

      reader.onload = function(){
        resolve(parser.parseFromString(reader.result, "text/xml"));
      };
      reader.readAsText(file, "utf-8");
      
    }catch(e){
      reject(e);
    }
  });
}

/**
 * GPXファイルを読み込む
 * @param {XMLDocument} gpx GPXファイル
 * @param {boolean} deletedupulicates 同じ緯度経度のポイントが連続したときに重複を削除するときtrue
 * @return {[{lat:number,lng:number,ele:number}]}
 */
function parseGPX(gpx, deletedupulicates = true){
  const trkpts = gpx.querySelectorAll("trkpt");
  const coords = [];
  
  console.log("GPX Track Points: " + trkpts.length);
  for(let i = 0; i < trkpts.length; i++){
    let lat = trkpts[i].getAttribute("lat") - 0;
    let lng = trkpts[i].getAttribute("lon") - 0;
    let ele = 0; //(trkpts[i].querySelector("ele")?.textContent - 0) ?? 0;
    
    if(deletedupulicates && (i > 0) && (coords[coords.length - 1].lat === lat) && (coords[coords.length - 1].lng === lng)){
      continue;
    }
    
    coords.push({
      lat: lat,
      lng: lng,
      ele: ele,
    });
  }
  addRouteInformation(coords);
  console.log("GPX Track Points (Dupulicates deleted): " + coords.length);
  
  return coords;
}

/**
 * TCXファイルを読み込む
 * @param {XMLDocument} tcx TCXファイル
 * @param {boolean} deletedupulicates 同じ緯度経度のポイントが連続したときに重複を削除するときtrue
 * @return {[{lat:number,lng:number,ele:number}]}
 */
function parseTCX(tcx, deletedupulicates = true){
  const trkpts = tcx.querySelectorAll("Trackpoint");
  const coords = [];

  console.log("TCX Track Points: " + trkpts.length);
  for(let i = 0; i < trkpts.length; i++){
    let lat = trkpts[i].querySelector("LatitudeDegrees").textContent - 0;
    let lng = trkpts[i].querySelector("LongitudeDegrees").textContent - 0;
    let ele = 0;
    
    if(deletedupulicates && (i > 0) && (coords[coords.length - 1].lat === lat) && (coords[coords.length - 1].lng === lng)){
      continue;
    }
    
    coords.push({
      lat: lat,
      lng: lng,
      ele: ele
    });
  }
  addRouteInformation(coords);
  console.log("TCX Track Points (Dupulicates deleted): " + coords.length);

  return coords;
}

/**
 * 読み込んだ(GPX, TCX)ルートデータに距離や地心直交座標の値などを追加する
 * @param {[{lat:number,lng:number,ele:number}]} coords
 * @return {[{lat:number,lng:number,ele:number,dist:number,X:number,Y:number,Z:number,mercatorX:number,mercatorY:number}]}
 */
function addRouteInformation(coords){
  const degree = Math.PI / 180.0;
  let d = 0.0;
  
  for(let i = 0; i < coords.length; i++){
    const lat = coords[i].lat;
    const lng = coords[i].lng;
    const ele = coords[i].ele;
    const XYZ = latlng2XYZ(lat, lng, ele);
    if(i > 0){
      d += hubeny4(coords[i - 1].lat, coords[i - 1].lng, lat, lng);
    }
    
    coords[i].dist = d;
    coords[i].mercatorX = lng * degree;
    coords[i].mercatorY = Math.asinh(Math.tan(lat * degree));
    coords[i].X = XYZ.X;
    coords[i].Y = XYZ.Y;
    coords[i].Z = XYZ.Z;
  }
}

/**
 * 緯度経度から地心直交座標系(X, Y, Z)に変換
 * @param {number} lat 緯度
 * @param {number} lng 経度
 * @param {number} h 高度(楕円体高)
 * @return {{X:number,Y:number,Z:number}}
 */
function latlng2XYZ(lat, lng, h = 0.0){
  const a = 6378137.0;
  const f = 1 / 298.257223563;
  const e2 = f * (2 - f);
  const f2 = 1 - e2;
  const degree = Math.PI / 180.0;
  
  const latrad = lat * degree;
  const lngrad = lng * degree;
  
  const sinlat = Math.sin(latrad);
  const coslat = Math.cos(latrad);
  const sinlng = Math.sin(lngrad);
  const coslng = Math.cos(lngrad);
  
  const w2 = 1.0 - sinlat * sinlat * e2;
  const w = Math.sqrt(w2)
  const N = a / w;
  
  return {
    "X": (N + h) * coslat * coslng,
    "Y": (N + h) * coslat * sinlng,
    "Z": (N * f2 + h) * sinlat,
  };
}

/**
 * 各アルゴリズムで線分を間引き、表示する
 */
function simplifyLines(){
  if(loaded_lines.length === 0){
    return;
  }
  const reduced_points_count = document.getElementById("reduced_points_count").value - 0;
  
  // 間引き後の距離を再計算
  function update_dists(coords){
    const result = [];
    let d = 0.0;
    result[0] = {
      ...(coords[0])
    }
    result[0].dist = d;
    for(let i = 1; i < coords.length; i++){
      result[i] = {...(coords[i])};
      d += hubeny4(coords[i - 1].lat, coords[i - 1].lng, coords[i].lat, coords[i].lng);
      result[i].dist = d;
    }
    return result;
  }
  
  // 間引き後の誤差を集計(lines_original.length > lines_original.lengthが必要)
  function calc_errors(lines_original, lines_reduced){
    let error_2d_max = -Number.MAX_VALUE;
    let error_2d_total = 0.0;
    let error_2d_sq_total = 0.0;
    let error_3d_max = -Number.MAX_VALUE;
    let error_3d_total = 0.0;
    let error_3d_sq_total = 0.0;
    let points_total = 0;
    
    for(let i = 0; i < lines_original.length; i++){
      const line1 = lines_original[i];
      const line2 = lines_reduced[i];
      let j = 0;
      let k = 0;
      points_total += line1.length;
      
      while((j < line1.length) && (k < line2.length - 1)){
        if((line1[j].lat === line2[k + 1].lat) && (line1[j].lng === line2[k + 1].lng)){
          j++;
          k++;
        }else{
          const error_2d = segmentPointDistance2D(line2[k], line1[j], line2[k + 1]);
          if(error_2d > error_2d_max){
            error_2d_max = error_2d;
          }
          error_2d_total += error_2d;
          error_2d_sq_total += error_2d * error_2d;
          
          const error_3d = segmentPointDistance3D(line2[k], line1[j], line2[k + 1]);
          if(error_3d > error_3d_max){
            error_3d_max = error_3d;
          }
          error_3d_total += error_3d;
          error_3d_sq_total += error_3d * error_3d;
          j++;
        }
      }
    }
    
    return {
      error_2d_max: error_2d_max,
      error_2d_average: error_2d_total / points_total,
      error_2d_deviation: error_2d_sq_total / points_total - (error_2d_total / points_total) ** 2,
      error_3d_max: error_3d_max,
      error_3d_average: error_3d_total / points_total,
      error_3d_deviation: error_3d_sq_total / points_total - (error_3d_total / points_total) ** 2
    };
    
    function segmentPointDistance2D(a, p, b){
      const ax = a.mercatorX;
      const ay = a.mercatorY;
      const bx = b.mercatorX;
      const by = b.mercatorY;
      const px = p.mercatorX;
      const py = p.mercatorY;
      
      let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
      if(t > 1){
        t = 1;
      }else if(t > 0){
      }else{
        // A = Bのとき(tがNaNのとき)を含む
        t = 0;
      }
      
      const x = ax - (ax - bx) * t;
      const y = ay - (ay - by) * t;
      
      return Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
    }
    
    function segmentPointDistance3D(a, p, b){
      const ax = a.X;
      const ay = a.Y;
      const az = a.Z;
      const bx = b.X;
      const by = b.Y;
      const bz = b.Z;
      const px = p.X;
      const py = p.Y;
      const pz = p.Z;
      
      let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py) + (az - bz) * (az - pz)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));
      if(t > 1){
        t = 1;
      }else if(t > 0){
      }else{
        // A = Bのとき(tがNaNのとき)を含む
        t = 0;
      }
      
      const x = ax - (ax - bx) * t;
      const y = ay - (ay - by) * t;
      const z = az - (az - bz) * t;
      
      return Math.sqrt((x - px) * (x - px) + (y - py) * (y - py) + (z - pz) * (z - pz));
    }
  }
  
  googlemap.deleteMapObjects("simplified_lines");
  const loaded_lines_total_dist = loaded_lines.map(e => e.coords[e.coords.length - 1].dist).reduce((i, e) => i + e);
  
  for(const algo of reduce_algorithms){
    let result;
    const key = algo.name + "-" + reduced_points_count;
    if(reduced_lines.has(key)){
      result = reduced_lines.get(key);
    }else{
      console.time(algo.name);
      const t1 = performance.now();
      const lines = loaded_lines.map(e => update_dists((algo.func)(e.coords, reduced_points_count)));
      const t2 = performance.now();
      console.timeEnd(algo.name);
      
      const error_info = calc_errors(loaded_lines.map(e => e.coords), lines);
      result = {
        name: algo.name,
        time: (t2 - t1),
        total_reduced_points: lines.map(e => e.length).reduce((i, e) => i + e),
        total_dists: lines.map(e => e[e.length - 1].dist).reduce((i, e) => i + e),
        lines: lines,
        ...error_info
      };
      console.log(result);
      reduced_lines.set(key, result);
      
    }
      
    if(document.getElementById(algo.checkbox_id).checked){
      for(const l of result.lines){
        googlemap.drawPolyline("simplified_lines", l, algo.color, 1, 3, algo.zindex, algo.name);
      }
    }
    
    document.getElementById(`${algo.checkbox_id}_time`).textContent = result.time.toFixed(1);
    document.getElementById(`${algo.checkbox_id}_points`).textContent = result.total_reduced_points;
    document.getElementById(`${algo.checkbox_id}_distance_error`).textContent = (result.total_dists - loaded_lines_total_dist).toFixed(3);
    document.getElementById(`${algo.checkbox_id}_2d_position_error_max`).textContent = result.error_2d_max.toExponential(3);
    document.getElementById(`${algo.checkbox_id}_2d_position_error_avg`).textContent = result.error_2d_average.toExponential(3);
  }
}

/**
 * Douglas-Peucker(2D)で線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function douglasPeucker(coords, reduced_points_count){
  return globallyResidualSelection(coords, reduced_points_count, function(a, p, b){
    const ax = a.mercatorX;
    const ay = a.mercatorY;
    const bx = b.mercatorX;
    const by = b.mercatorY;
    const px = p.mercatorX;
    const py = p.mercatorY;/*
    const ax = a.lng;
    const ay = a.lat;
    const bx = b.lng;
    const by = b.lat;
    const px = p.lng;
    const py = p.lat;*/
    
    let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
    if(t > 1){
      t = 1;
    }else if(t > 0){
    }else{
      // A = Bのとき(tがNaNのとき)を含む
      t = 0;
    }
    
    const x = ax - (ax - bx) * t;
    const y = ay - (ay - by) * t;
    return ((x - px) * (x - px) + (y - py) * (y - py));
  });
}

/**
 * Douglas-Peucker(3D)で線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function douglasPeucker3D(coords, reduced_points_count){
  return globallyResidualSelection(coords, reduced_points_count, function(a, p, b){
    const ax = a.X;
    const ay = a.Y;
    const az = a.Z;
    const bx = b.X;
    const by = b.Y;
    const bz = b.Z;
    const px = p.X;
    const py = p.Y;
    const pz = p.Z;
    
    let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py) + (az - bz) * (az - pz)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));
    if(t > 1){
      t = 1;
    }else if(t > 0){
    }else{
      // A = Bのとき(tがNaNのとき)を含む
      t = 0;
    }
    
    const x = ax - (ax - bx) * t;
    const y = ay - (ay - by) * t;
    const z = az - (az - bz) * t;
    
    return ((x - px) * (x - px) + (y - py) * (y - py) + (z - pz) * (z - pz));
  });
}

/**
 * Douglas-Peuckerにおいて、線分との距離ではなく減少する距離を使う(arclengthを大域的に行う)
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function arcLengthG(coords, reduced_points_count){
  return globallyResidualSelection(coords, reduced_points_count, function(a, b, c){
    return hubeny4(a.lat, a.lng, b.lat, b.lng) + hubeny4(b.lat, b.lng, c.lat, c.lng) - hubeny4(a.lat, a.lng, c.lat, c.lng);
  });
}

/**
 * Cross-Track(GPSBabelのデフォルト)で線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function crossTrack(coords, reduced_points_count){
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const ax = a.mercatorX;
      const ay = a.mercatorY;
      const bx = c.mercatorX;
      const by = c.mercatorY;
      const px = b.mercatorX;
      const py = b.mercatorY;
      
      let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
      if(t > 1){
        t = 1;
      }else if(t > 0){
      }else{
        // A = Bのとき(tがNaNのとき)を含む
        t = 0;
      }
      
      const x = ax - (ax - bx) * t;
      const y = ay - (ay - by) * t;
      return ((x - px) * (x - px) + (y - py) * (y - py));
    }
  );
}
/**
 * Cross-Track(3D)で線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function crossTrack3D(coords, reduced_points_count){
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const ax = a.X;
      const ay = a.Y;
      const az = a.Z;
      const bx = c.X;
      const by = c.Y;
      const bz = c.Z;
      const px = b.X;
      const py = b.Y;
      const pz = b.Z;
      
      const t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py) + (az - bz) * (az - pz)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by) + (az - bz) * (az - bz));
      if(t > 1){
        t = 1;
      }else if(t > 0){
      }else{
        // A = Bのとき(tがNaNのとき)を含む
        t = 0;
      }
      
      const x = ax - (ax - bx) * t;
      const y = ay - (ay - by) * t;
      const z = az - (az - bz) * t;
      
      return ((x - px) * (x - px) + (y - py) * (y - py) + (z - pz) * (z - pz));
    }
  );
}

/**
 * Arc-Length(GPSBabelのarclengthエミュレート、距離の差が小さくなる点を削除)で線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function arcLength(coords, reduced_points_count){
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      return hubeny4(a.lat, a.lng, b.lat, b.lng) + hubeny4(b.lat, b.lng, c.lat, c.lng) - hubeny4(a.lat, a.lng, c.lat, c.lng);
    }
  );
}

/**
 * Visvalingam-Whyattで線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function visvalingamWhyatt(coords, reduced_points_count){
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const x1 = a.mercatorX;
      const y1 = a.mercatorY;
      const x2 = b.mercatorX;
      const y2 = b.mercatorY;
      const x3 = c.mercatorX;
      const y3 = c.mercatorY;
      return Math.abs((-(x2*y1) + x3*y1 + x1*y2 - x3*y2 - x1*y3 + x2*y3) * 0.5);
    }
  );
}

/**
 * Visvalingam-Whyatt3Dで線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function visvalingamWhyatt3D(coords, reduced_points_count){
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const x1 = a.X;
      const y1 = a.Y;
      const z1 = a.Z;
      const x2 = b.X;
      const y2 = b.Y;
      const z2 = b.Z;
      const x3 = c.X;
      const y3 = c.Y;
      const z3 = c.Z;
      
      return (x2*y1 - x3*y1 - x1*y2 + x3*y2 + x1*y3 - x2*y3) ** 2 + (x2*z1 - x3*z1 - x1*z2 + x3*z2 + x1*z3 - x2*z3) ** 2 + (y2*z1 - y3*z1 - y1*z2 + y3*z2 + y1*z3 - y2*z3) ** 2;
    }
  );
}

/**
 * Kashimir3D(距離優先)をエミュレートしたい
 *   距離が最も短い線分の両端の点のうち、他方への距離が短いほうを削除している?
 *   前後の点の距離の合計が短いほうを削除している?
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function kashmir3D(coords, reduced_points_count){
  /*const result = [];
  for(let i = 0; i < coords.length; i++){
    result.push({...coords[i]});
  }
  for(let i = 1; i < result.length; i++){
    result[i].dist_interval = result[i].dist - result[i - 1].dist;
  }
  
  while(result.length > reduced_points_count){
    let min_index = -1;
    let min_interval = Number.MAX_VALUE;
    
    for(let i = 1; i < result.length; i++){
      if(result[i].dist_interval < min_interval){
        min_index = i;
        min_interval = result[i].dist_interval;
      }
    }
    
    let delete_index = -1;
    if(min_index === 1){
      delete_index = min_index;
    }else if(min_index === result.length - 1){
      delete_index = min_index - 1;
    }else{
      if(result[min_index - 1].dist_interval < result[min_index + 1].dist_interval){
        delete_index = min_index - 1;
      }else{
        delete_index = min_index;
      }
    }
    
    result[delete_index + 1].dist_interval = hubeny(result[delete_index - 1].lat, result[delete_index - 1].lng, result[delete_index + 1].lat, result[delete_index + 1].lng);
    result.splice(delete_index, 1);
  }
  
  return result;*/
  /*
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const dist1 = hubeny(a.lat, a.lng, b.lat, b.lng);
      const dist2 = hubeny(b.lat, b.lng, c.lat, c.lng);
      
      const dist_min = Math.min(dist1, dist2);
      const dist_max = Math.max(dist1, dist2);
      
      console.assert(dist_max * 1e-6 < 1, {dist_min, dist_max});
      
      return Math.floor(dist_min * 1e3) + Math.min(dist_max * 1e-6, 1);
    }
  );*/
  return locallyEliminationSelection(coords, reduced_points_count, 
    function(a, b, c){
      const dist1 = hubeny(a.lat, a.lng, b.lat, b.lng);
      const dist2 = hubeny(b.lat, b.lng, c.lat, c.lng);
      
      return dist1 + dist2;
    }
  );
}

/**
 * Reumann-Witkamで線分を簡略化
 * 削減後の点数を指定できないので、閾値を変化させながら探索
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function ReumannWitkam(coords, reduced_points_count){
  const result = [];
  let flags = [];
  let epsilon = 1e-5;
  
  if(reduced_points_count < coords.length){
    for(let k = 0; k < 100; k++){
      flags = coords.map(e => false);
      flags[0] = true;
      flags[flags.length - 1] = true;
      
      let i = 0;
      let j = 2;
      while(j < coords.length){
        if(linePointDistance2D(coords[i], coords[j], coords[i + 1]) > epsilon){
          flags[j - 1] = true;
          i = j - 1;
          j = i + 2;
        }else{
          j = j + 1;
        }
      }
      
      let count = flags.filter(e => (e === true)).length;
      console.log({epsilon, count});
      if(count < 0.9 * reduced_points_count){
        epsilon = epsilon * (count / reduced_points_count);
      }else if(reduced_points_count < count){
        epsilon = epsilon * Math.max((count / reduced_points_count), 1.01);
      }else{
        break;
      }
    }
  }else{
    flags = coords.map(e => true);
  }
  
  for(let i = 0; i < flags.length; i++){
    if(flags[i]){
      result.push({...coords[i]});
    }
  }
  
  return result;

  // 直線ABと点Pの距離(線分ではない)
  function linePointDistance2D(a, p, b){
    const ax = a.mercatorX;
    const ay = a.mercatorY;
    const bx = b.mercatorX;
    const by = b.mercatorY;
    const px = p.mercatorX;
    const py = p.mercatorY;
    
    let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
    
    const x = ax - (ax - bx) * t;
    const y = ay - (ay - by) * t;
    
    return Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
  }
}

/**
 * Langで線分を簡略化
 * 削減後の点数を指定できないので、閾値を変化させながら探索
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function Lang(coords, reduced_points_count){
  const result = [];
  let flags = [];
  const leap = Math.min(1000, 10 * Math.ceil(coords.length / reduced_points_count));
  let epsilon = 1e-5;
  
  if(reduced_points_count < coords.length){
    for(let k = 0; k < 100; k++){
      flags = coords.map(e => false);
      flags[0] = true;
      flags[flags.length - 1] = true;
      
      let i = 0;
      let j = leap;
      while(i < coords.length - 1){
        for(j = Math.min(coords.length - 1, i + leap); j >= i + 1; j--){
          let b = true;
          for(let a = i + 1; a < j; a++){
            if(linePointDistance2D(coords[i], coords[a], coords[j]) > epsilon){
              b = false;
              break;
            }
          }
          if(b){
            break;
          }
        }
        flags[j] = true;
        i = j;
      }
      
      let count = flags.filter(e => (e === true)).length;
      console.log({leap, epsilon, count});
      if(count < 0.9 * reduced_points_count){
        epsilon = epsilon * (count / reduced_points_count);
      }else if(reduced_points_count < count){
        epsilon = epsilon * Math.max((count / reduced_points_count), 1.01);
      }else{
        break;
      }
    }
  }else{
    flags = coords.map(e => true);
  }
  
  for(let i = 0; i < flags.length; i++){
    if(flags[i]){
      result.push({...coords[i]});
    }
  }
  
  return result;

  // 直線ABと点Pの距離(線分ではない)
  function linePointDistance2D(a, p, b){
    const ax = a.mercatorX;
    const ay = a.mercatorY;
    const bx = b.mercatorX;
    const by = b.mercatorY;
    const px = p.mercatorX;
    const py = p.mercatorY;
    
    let t = ((ax - bx) * (ax - px) + (ay - by) * (ay - py)) / ((ax - bx) * (ax - bx) + (ay - by) * (ay - by));
    
    const x = ax - (ax - bx) * t;
    const y = ay - (ay - by) * t;
    
    return Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
  }
}

/**
 * Nth-Pointで線分を簡略化
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function nthPoint(coords, reduced_points_count){
  const result = [];
  
  if(reduced_points_count < coords.length){
    for(let i = 0; i < reduced_points_count; i++){
      result.push(coords[Math.round(i * (coords.length - 1) / (reduced_points_count - 1))]);
    }
  }else{
    result.push(...coords);
  }
  
  return result;

}

/**
 * 一般化した線分を簡略化(大域的に残す点を選ぶ)
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @param {Function} priority_func 優先度関数(DPにおける距離関数)
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function globallyResidualSelection(coords, reduced_points_count, priority_func){
  const pts = [];
  const queue = new MaxPriorityQueue();
  const flag = []; // 残すポイントをtrue
  const degree = Math.PI / 180.0;
  let count = 2;
  let v = null;
  
  for(let i = 0; i < coords.length; i++){
    pts[i] = {
      ...(coords[i])
    };
    flag[i] = false;
  }
  
  let farthest = findFarthest(pts, 0, pts.length - 1);
  queue.enqueue(farthest.dist, farthest);
  flag[0] = true;
  flag[pts.length - 1] = true;
  
  while(queue.size() && count < reduced_points_count){
    v = queue.dequeue();
    flag[v.pos] = true;
    count++;
    
    if(v.start + 2 <= v.pos){
      farthest = findFarthest(pts, v.start, v.pos);
      queue.enqueue(farthest.dist, farthest);
    }
    if(v.pos + 2 <= v.end){
      farthest = findFarthest(pts, v.pos, v.end);
      queue.enqueue(farthest.dist, farthest);
    }
  }
  
  const result = [];
  for(let i = 0; i < coords.length; i++){
    if(flag[i]){
      result.push(coords[i]);
    }
  }
  
  return result;

  function findFarthest(pts, start, end){
    const a = pts[start];
    const b = pts[end];
    let d = 0.0;
    let m = -Number.MAX_VALUE;
    let c = -1;
    
    for(let i = start + 1; i < end; i++){
      d = priority_func(a, pts[i], b);
      if(m < d){
        m = d;
        c = i;
      }
    }
    
    return {start:start, end:end, pos:c, dist:m};
  }
}

/**
 * 一般化した線分簡略化関数(局所的に削除点を選ぶ)
 * @param {[{lat:number,lng:number}]} coords
 * @param {int} reduced_points_count 削減後の要素数
 * @param {Function} priority_func 優先度関数(DPにおける距離関数)
 * @return {[{lat:number,lng:number}]} 削減後のcoords
 */
function locallyEliminationSelection(coords, reduced_points_count, priority_func){
  const pts = [];
  const degree = Math.PI / 180.0;
  let count = coords.length;
  
  for(let i = 0; i < coords.length; i++){
    pts[i] = {
      ...coords[i],
      prev: null,
      next: null,
      priority: Number.MAX_VALUE,
      id: i,
      flag: true
    };
  }
  
  for(let i = 1; i < coords.length - 1; i++){
    pts[i].prev = pts[i - 1];
    pts[i].next = pts[i + 1];
    pts[i].priority = priority_func(pts[i - 1], pts[i], pts[i + 1]);
  }
  //const queue = new changableBinaryHeap(pts.slice(1, -1).map(e => e.priority), pts.slice(1, -1));
  const queue = new deletablePriorityQueue(pts.slice(1, -1).map(e => e.priority), pts.slice(1, -1));
  
  while(count > reduced_points_count){
    const min = queue.dequeue();
    min.flag = false;
    count--;
    
    const prevprev = min.prev?.prev;
    const prev = min.prev;
    const next = min.next;
    const nextnext = min.next?.next;
    if(prevprev){
      prev.next = next;
      const oldpriority = prev.priority;
      const newpriority = priority_func(prevprev, prev, next);
      prev.priority = newpriority;
      queue.changepriority(newpriority, prev, oldpriority);
    }
    if(nextnext){
      next.prev = prev;
      const oldpriority = next.priority;
      const newpriority = priority_func(prev, next, nextnext);
      next.priority = newpriority;
      queue.changepriority(newpriority, next, oldpriority);
    }
  }
  
  const result = [];
  for(let i = 0; i < pts.length; i++){
    if(pts[i].flag){
      result.push(coords[i]);
    }
  }
  
  return result;
}

// 最大Pairingヒープ
function MaxPriorityQueue(){
  this.name = "Pairing Heap";
  this._size = 0;
  this._root = null;
  
  this._merge = function (i, j){
    if(i === null) return j;
    if(j === null) return i;
    
    if(i.p < j.p){
      let ret = i;
      i = j;
      j = ret;
    }
    j.next = i.head;
    i.head = j;
    
    return i;
  };
  this._mergeList = function (s){
    let n = null;
    
    while(s !== null){
      let a = s;
      let b = null;
      s = s.next;
      a.next = null;
      if(s !== null){
        b = s;
        s = s.next;
        b.next = null;
      }
      a = this._merge(a, b);
      a.next = n;
      n = a;
    }
    while(n !== null){
      let j = n;
      n = n.next;
      s = this._merge(j, s);
    }
    return s;
  };
  
  this.enqueue = function(priority, value){
    this._root = this._merge(this._root, {
      p: priority,
      v: value,
      next: null,
      head: null
    });
    this._size++;
  };
  this.dequeue = function(){
    let result = this._root.v;
    this._root = this._mergeList(this._root.head);
    this._size--;
    
    return result;
  };
  this.size = function(){
    return this._size;
  };
  
  return this;
}

// 削除操作(優先度変更操作)に対応した優先度付きキュー
class deletablePriorityQueue {
  constructor(priorities, values){
    this._queue = new d_ary_heap_min();
    this._deletelist = new Map();
    
    for(let i = 0; i < priorities.length; i++){
      this.enqueue(priorities[i], values[i]);
    }
  }
  
	enqueue(priority, value){
    this._queue.enqueue(priority, value);
	}
  
  dequeue(){
    let result = this._queue.dequeue();
    while((this._deletelist.has(result.v) === true) && (this._deletelist.get(result.v).includes(result.p) === true)){
      // 削除リストから1個だけ削除(同じ優先度、同じ値で複数入ることがある)
      const tmp = this._deletelist.get(result.v);
      for(let i = 0; i < tmp.length; i++){
        if(tmp[i] === result.p){
          tmp.splice(i, 1);
          break;
        }
      }
      result = this._queue.dequeue();
    }
    
    return result.v;
  }
  
  changepriority(newpriority, value, oldpriority){
    if(!this._deletelist.has(value)){
      this._deletelist.set(value, [])
    }
    this._deletelist.get(value).push(oldpriority);
    this._queue.enqueue(newpriority, value);
  }
}

// 最小d-aryヒープ(dequeue時に優先度も一緒に返す)
function d_ary_heap_min(d){
  "use strict";
	const _d = d || 4;
	const _data = [];
	let _size = 0;
	const _dinv = 1 / _d;
	const enqueue = function(priority, value){
		const data = _data;
		
		if(_size){
			data.push({p: priority, v: value});
			let i = _size;
			let p = ~~((i - 1) * _dinv);
			while(p >= 0){
				if(data[p].p > data[i].p){
					const ret = data[i];
					data[i] = data[p];
					data[p] = ret;
				
					i = p;
					p = ~~((i - 1) * _dinv);
				}else{
					break;
				}
			}
		}else{
			data.push({p: priority, v: value});
		}
		_size = _size + 1;
	};
	const dequeue = function(){
		const data = _data;
		const size = _size - 1;
		let i = 0;
		let c = 1;
		
		if(_size){
			const result = data[0];
			data[0] = data[size];
			data.pop();
			
			while(c < size){
				const p0 = data[i].p;
				let pmax = data[c].p;
				let cmax = c;
				
				let jmax = c + _d;
				if(jmax > size){
					jmax = size;
				}
				for(let j = c + 1; j < jmax; j++){
					let pret = data[j].p;
					if(pmax > pret){
						pmax = pret;
						cmax = j;
					}
				}
				if(p0 > pmax){
					let ret = data[i];
					data[i] = data[cmax];
					data[cmax] = ret;
				}else{
					break;
				}
				i = cmax;
				c = i * _d + 1;
			}
			
			_size = size;
			return result;
		}else{
			return (void 0);
		}
	};
	const top = function(){
		return _data[0];
	};
	const size = function(){
		return _size;
	};
	
	return {
		name: "d-ary Heap (d=" + _d + ")",
		enqueue: enqueue,
		dequeue: dequeue,
		top: top,
		size: size
	};
}

// 優先度変更操作を可能にした最小BinaryHeap
class changableBinaryHeap {
  constructor(priorities, values){
    this._data = [];
    this._size = 0;
    
    for(let i = 0; i < priorities?.length; i++){
      this.enqueue(priorities[i], values[i]);
    }
  }
  
	enqueue(priority, value){
		const data = this._data;
		
		if(this._size){
			data.push({p: priority, v: value});
			let i = this._size;
			let p = (i - 1) >> 1;	// parent
			while(p >= 0){
				if(data[p].p > data[i].p){
					const ret = data[i];
					data[i] = data[p];
					data[p] = ret;
				
					i = p;
					p = (i - 1) >> 1;//Math.floor((i - 1) * 0.5);
				}else{
					break;
				}
			}
		}else{
			data.push({p: priority, v: value});
		}
		this._size = this._size + 1;
	}
  
  dequeue(){
		const data = this._data;
		const size = this._size - 1;
		
		if(this._size){
			const result = data[0];
			data[0] = data[size];
			data.pop();
			let i = 0;
			let c1 = 1;	// left child
			let c2 = 2;	// right child
			
			while(c1 < size){
				if(c2 < size){
					const p0 = data[i].p;
					const p1 = data[c1].p;
					const p2 = data[c2].p;
				
					if((p1 > p2) && (p0 > p2)){
						const ret = data[i];
						data[i] = data[c2];
						data[c2] = ret;
						i = c2;
					}else if(p0 > p1){
						const ret = data[i];
						data[i] = data[c1];
						data[c1] = ret;
						i = c1;
					}else{
						break;
					}
					c1 = (i << 1) + 1;
					c2 = (i << 1) + 2;
				}else{
					const p0 = data[i].p;
					const p1 = data[c1].p;
					
					if(p0 > p1){
						const ret = data[i];
						data[i] = data[c1];
						data[c1] = ret;
					}
					break;
				}
			}
			
			this._size = size;
			return result.v;
		}else{
			return (void 0);
		}
	}
  
	top(){
		return this._data[0].v;
	}
  
  changepriority(newpriority, value){
    const data = this._data;
    for(let i = 0; i < data.length; i++){
      if(data[i].v === value){
        // 変更対象が見つかった
        if(data[i].p < newpriority){
          // 下に向かってヒープ構造を維持する
          data[i].p = newpriority;
					let c1 = (i << 1) + 1;
					let c2 = (i << 1) + 2;
          
          while(c1 < this._size){
            if(c2 < this._size){
              const p0 = data[i].p;
              const p1 = data[c1].p;
              const p2 = data[c2].p;
            
              if((p1 > p2) && (p0 > p2)){
                const ret = data[i];
                data[i] = data[c2];
                data[c2] = ret;
                i = c2;
              }else if(p0 > p1){
                const ret = data[i];
                data[i] = data[c1];
                data[c1] = ret;
                i = c1;
              }else{
                break;
              }
              c1 = (i << 1) + 1;
              c2 = (i << 1) + 2;
            }else{
              const p0 = data[i].p;
              const p1 = data[c1].p;
              
              if(p0 > p1){
                const ret = data[i];
                data[i] = data[c1];
                data[c1] = ret;
              }
              break;
            }
          }
        }else{
          // 上に向かってヒープ構造を維持する
          data[i].p = newpriority;
          let p = (i - 1) >> 1;	// parent
          while(p >= 0){
            if(data[p].p > data[i].p){
              const ret = data[i];
              data[i] = data[p];
              data[p] = ret;
            
              i = p;
              p = (i - 1) >> 1;
            }else{
              break;
            }
          }
        }
        
        break;
      }
    }
  }
	size(){
		return this._size;
	}
}

/**
 * loaded_linesを表示する
 * @param {boolean} recalc_simplify_lines 間引いた線を再計算して表示する場合はtrue
 */
function drawLoadedLines(recalc_simplify_lines){
  const colors = ["#000"];//["#3f3d9a", "#9a3d71", "#9a8c3d", "#3d9a56", "#3d5a9a", "#9a3d90", "#9a6d3d", "#439a3d", "#3d799a", "#843d9a", "#9a4e3d", "#629a3d"];
  
  let min_lat = Number.MAX_VALUE;
  let min_lng = Number.MAX_VALUE;
  let max_lat = -Number.MAX_VALUE;
  let max_lng = -Number.MAX_VALUE;
  
  for(let i = 0; i < loaded_lines.length; i++){
    const coords = loaded_lines[i].coords;
    
    googlemap.drawPolyline("gpx_lines", coords, colors[i % colors.length], 0.5, 10, 0, loaded_lines[i].name);
    for(let j = 0; j < coords.length; j++){
      if(coords[j].lat < min_lat) min_lat = coords[j].lat;
      if(coords[j].lng < min_lng) min_lng = coords[j].lng;
      if(coords[j].lat > max_lat) max_lat = coords[j].lat;
      if(coords[j].lng > max_lng) max_lng = coords[j].lng;
    }
  }
  
  if(min_lat < Number.MAX_VALUE){
    googlemap.map.fitBounds({
      south: min_lat,
      west: min_lng,
      north: max_lat,
      east: max_lng
    });
  }
  
  const loaded_lines_total_points = loaded_lines.map(e => e.coords.length).reduce((i, e) => i + e);
  document.getElementById("original_points").textContent = loaded_lines_total_points;
  
  if(recalc_simplify_lines){
    reduced_lines.clear();
    simplifyLines();
  }
}

window.addEventListener("DOMContentLoaded", function(){
  // GPX/TCX読み込み対応
  document.getElementById("gpx_file").addEventListener("change", async function(evt){
    // GPX/TCXファイルの読み込み
    try{
      if(evt.target.files.length > 0){
        showLoader();
        googlemap.clearMap();
        loaded_lines.length = 0;

        for(let i = 0; i < evt.target.files.length; i++){
          console.log(evt.target.files[i]);
          const xml = await readXML(evt.target.files[i]);
          let coords = null;
          if(evt.target.files[i].name.match(/\.gpx$/i)){
            coords = parseGPX(xml);
          }
          if(evt.target.files[i].name.match(/\.tcx$/i)){
            coords = parseTCX(xml);
          }
          
          if(coords){
            loaded_lines.push({
              coords: coords,
              name: evt.target.files[i].name
            });
          }
        }
        
        drawLoadedLines(true);
      }
    }catch(err){
      console.error(err);

    }finally{
      hideLoader();
      //document.getElementById("reduced_points_count").focus();
    }
  });
  // 同じファイルを選択したときもchangeイベントを発生させるハック
  document.getElementById("gpx_file").addEventListener("click", function(e){
    e.target.value = "";
  });
  
  // アルゴリズムの一覧表を生成
  {
    const buf = [];
    buf.push("<table><tr><th></th><th>Algorithm</th><th>Points</th><th>Time (ms)</th><th>Distance Error (m)</th><th>2D Position Error Max</th><th>2D Position Error Avg.</th></tr>");
    buf.push(`<tr><td><\/td><td><span style="color: #888;">■<\/span> Original<\/td><td id="original_points"><\/td><td>-<\/td><td>-<\/td><td>-<\/td><td>-<\/td><\/tr>`);
    for(const a of reduce_algorithms){
      buf.push(`<tr>`);
      buf.push(`<td><input id="${a.checkbox_id}" type="checkbox" ${a.checked}><\/td>`);
      buf.push(`<td><label for="${a.checkbox_id}"><span style="color: ${a.color};">■<\/span> ${a.name}<\/label><\/td>`);
      buf.push(`<td id="${a.checkbox_id}_points"><\/td>`);
      buf.push(`<td id="${a.checkbox_id}_time"><\/td>`);
      buf.push(`<td id="${a.checkbox_id}_distance_error"><\/td>`);
      buf.push(`<td id="${a.checkbox_id}_2d_position_error_max"><\/td>`);
      buf.push(`<td id="${a.checkbox_id}_2d_position_error_avg"><\/td>`);
      buf.push(`<\/tr>`);
    }
    buf.push(`<\/table>`);
    
    document.getElementById("analysis_table").innerHTML = buf.join("");
  }
  
  for(const n of document.querySelectorAll("#analysis_table input, #reduced_points_count")){
    n.addEventListener("change", function(){
      showLoader();
      setTimeout(function(){
        simplifyLines();
        hideLoader();
      }, 0);
    });
  }
  
  // ドラッグドロップ対応
  {
    const droparea = document.body;
    const overlay = document.getElementById("overlay");
    droparea.addEventListener("dragover", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "block";
    }, false);
    overlay.addEventListener("dragleave", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
    }, false);
    overlay.addEventListener("drop", function(e){
      e.stopPropagation();
      e.preventDefault();
      overlay.style.display = "none";
      
      const files = e.dataTransfer.files;
      document.getElementById("gpx_file").files = files;

      const evt = new Event("change");
      document.getElementById("gpx_file").dispatchEvent(evt);
    }, false)
  };
  
  // デモ用コースファイル読み込み
  setTimeout(loadDemoRoute, 1);
});

// 戻るボタンを押されたときにフォームの値が残っているとき
window.addEventListener("pageshow", function(evt){
  document.getElementById("gpx_file").dispatchEvent(new Event("change"));
});

// デモルートを読み込む
async function loadDemoRoute(demo_url = "demo_route_003.gpx", title = "Demo Route"){
  const gpx = await fetch(demo_url);
  const text = await gpx.text();
  const parser = new DOMParser();
  
  googlemap.clearMap();
  loaded_lines.length = 0;
  
  loaded_lines.push({
    coords: parseGPX(parser.parseFromString(text, "text/xml")),
    name: title
  });
  
  drawLoadedLines(true);
}

function hideLoader(){
  document.getElementById("loader_bg").style.display = "none";
}

function showLoader(){
  document.getElementById("loader_bg").style.display = "block";
}


// ドラッグドロップ失敗時にファイルがダウンロードされるのを防止
window.addEventListener("dragover", function(e){
  e = e || event;
  e.preventDefault();
}, false);
window.addEventListener("drop", function(e){
  e = e || event;
  e.preventDefault();
}, false);

/**
 * Google Mapsに表示するオブジェクトを管理するクラス
 */
class GoogleMapManager {
  constructor(mapdiv){
    this.map = new google.maps.Map(mapdiv, {
      zoom: 6,
      mapTypeId: google.maps.MapTypeId.ROADMAP,
      center: new google.maps.LatLng(35.681382, 139.766084),
      fullscreenControl: false,
      options: {
        gestureHandling: "greedy"
      }
    });
    this.mapobjects = new Map();
    
    this.map.addListener("contextmenu", this.clearMap);
  }
  
  /**
   * 地図上のすべてのオブジェクトを削除
   */
  clearMap(){
    for(const objarray of this.mapobjects.values()){
      for(const e of objarray){
        e.setMap(null);
      }
    }
    this.mapobjects.clear();
  }
  
  /**
   * PolylineをGoogle Mapsに表示
   * @param {string} label 削除するときのグループ名
   * @param {[lat:number,lng:number,dist:number}]} coords
   * @param {string} color
   * @param {number} opacity
   * @param {number} weight
   * @param {number} zindex
   * @param {string} title
   * @return {void}
   */
  drawPolyline(label, coords, color, opacity, weight, zindex, title){
    // 表示用のPolyline
    const line_display = new google.maps.Polyline({
      path: coords,
      geodesic: true,
      strokeColor: color,
      strokeOpacity: opacity,
      strokeWeight: weight,
      zIndex: zindex
    });
    // マウスイベントを拾うための透明なPolyline
    const line_transparent = new google.maps.Polyline({
      path: coords,
      geodesic: true,
      strokeColor: color,
      strokeOpacity: 0,
      strokeWeight: 30,
      zIndex: 10000 + zindex
    });

    const dist_info = document.getElementById("dist_info");

    line_transparent.addListener("mousemove", function(evt){
      // GPXトラック上にマウスが来たときは距離を表示する
      const lat = evt.latLng.lat();
      const lng = evt.latLng.lng();
      let dist_min = Number.MAX_VALUE;
      let index_min = -1;

      for(let i = 0; i < coords.length; i++){
        let d = hubeny4(coords[i].lat, coords[i].lng, lat, lng);
        if(d < dist_min){
          index_min = i;
          dist_min = d;
        };
      }

      //console.log(coords[index_min]);
      //console.log(evt);
      if(googlemap.dist_marker){
        googlemap.dist_marker.setPosition(coords[index_min]);

      }else{
        googlemap.dist_marker = new google.maps.Marker({
          position: coords[index_min],
          icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 5,
              fillColor: color,
              fillOpacity: 0.5,
              strokeColor: color,
              strokeOpacity: 1,
              strokeWeight: 1
          },
          map: googlemap.map
        });
      }
      
      dist_info.innerHTML = title + ": " + (0.001 * coords[index_min].dist).toFixed(3) + " km";
      dist_info.style.display = "block";
      dist_info.style.left = (evt.domEvent.pageX - dist_info.clientWidth * 0.5) + "px";
      dist_info.style.top = (evt.domEvent.pageY - dist_info.clientHeight - 20) + "px";

    });
    line_transparent.addListener("mouseout", function(evt){
      dist_info.style.display = "none";
      if(googlemap.dist_marker){
        googlemap.dist_marker.setMap(null);
        googlemap.dist_marker = null;
      }
    });
    
    if(!this.mapobjects.has(label)){
      this.mapobjects.set(label, []);
    }
    this.mapobjects.get(label).push(line_display);
    this.mapobjects.get(label).push(line_transparent);
    line_display.setMap(this.map);
    line_transparent.setMap(this.map);
  }
  
  /**
   * 指定したラベルのオブジェクトを地図上から削除する
   */
  deleteMapObjects(label){
    if(this.mapobjects.has(label)){
      for(const obj of this.mapobjects.get(label)){
        obj.setMap(null);
      }
      this.mapobjects.set(label, []);
    }
  }
}
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4RTVKDCC9W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4RTVKDCC9W');
</script>
<style>
* { margin: 0; padding: 0; }
html, body {
  width: 100%;
  height: 100%;
  font-family: sans-serif;
  line-height: 1em;
  font-size: 16px;
}

#wrapper {
  width: 100%;
  height: 100%;
  overflow: hidden;
  
  display: flex;
  flex-direction: column;
}

#map_canvas {
  flex: 10 0 auto;
}
#top_panel {
  flex: 0 0 32px;
  line-height: 32px;
  vertical-align: top;
  width: 100%;
  background-color: #ddd;
  display: flex;
  justify-content: center;
}
h1 {
  flex: 0 0 32px;
  line-height: 32px;
  width: 100%;
  font-size: 22px;
  text-align: center;
  background-color: #ddd;
  box-sizing: border-box;
}
#flexbox_gpx_file {
  flex: 0 1 300px;
  height: 32px;
  min-width: 150px;
  box-sizing: border-box;
}
#flexbox_reduced_points_count {
  flex: 0 0 auto;
  height: 32px;
  box-sizing: border-box;
}
#flexbox_reduced_points_count span {
  text-overflow: ellipsis;
}
#flexbox_reduced_points_count select {
  font-size: 16px;
  height: 24px;
}
#flexbox_load_demo {
  flex: 0 0 120px;
  height: 32px;
}
#flexbox_load_demo button {
  width: 100%;
  height: 24px;
}

#flexbox_github_link {
  flex: 0 0 32px;
  height: 24px;
  padding: 3px 3px;
}

#analysis_table {
  flex: 0 0 auto;
  text-align: center;
  background-color: #f8f8f8;
}
#analysis_table table {
  width: 100%;
  border-collapse: collapse;
  line-height: normal;
}
#analysis_table table th, #analysis_table table td {
  border: 1px solid gray;
  text-align: center;
}
#analysis_table label {
  display: inline-block;
  width: 100%;
  cursor: pointer;
}

#loader_bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(1, 1, 1, 0.25);
  z-index: 9999;
}
#loader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 10px;
  border-radius: 30px;
  background: #ddd;
}

#dist_info {
  position: absolute;
  display: none;
  top: 0;
  left: 0;
  z-index: 9999;
  padding: 3px;
  background-color: #eee;
  border-radius: 3px;
  border-width: 1px;
  border-color: #000;
  border-style: solid;
}

.hotel_selected {
  background: #ccc;
}

#gpx_file { 
  /*display: none;*/
  width: 100%;
}

#overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  background-color: #ddd;
  opacity: 0.5;
  display: none;
}

.dropover {
  background-color: rgba(240, 240, 240, 0.5);
  display: block;
}
</style>
</head>
<body>
<div id="wrapper">
 <h1>GPS Track Line Simplification Algorithms Comparison</h1>
 <div id="top_panel">
  <div id="flexbox_gpx_file"><input type="file" id="gpx_file" accept=".gpx,.tcx" multiple /></div>
  <div id="flexbox_reduced_points_count">
   <label for="reduced_points_count"><span>Reduce Points Target:</span>
    <select id="reduced_points_count">
     <option value="100">100</option>
     <option value="200" selected>200</option>
     <option value="300">300</option>
     <option value="400">400</option>
     <option value="500">500</option>
     <option value="1000">1000</option>
     <option value="2000">2000</option>
     <option value="3000">3000</option>
     <option value="4000">4000</option>
     <option value="5000">5000</option>
     <option value="10000">10000</option>
     <option value="20000">20000</option>
     <option value="30000">30000</option>
     <option value="40000">40000</option>
     <option value="50000">50000</option>
     <option value="100000">100000</option>
    </select>
   </label>
  </div>
  <!--<div id="flexbox_load_demo">
   <button id="button_load_demo">Load Demo Route</button>
  </div>-->
  <div id="flexbox_github_link">
   <a href="https://github.com/330k/line_simplify_demo" target="_blank">
   <svg height="24" aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="24" data-view-component="true" class="octicon octicon-mark-github v-align-middle"><path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path></svg>
   </a>
  </div>
 </div>
 <div id="analysis_table"></div>
 <div id="map_canvas"></div>
</div>
<div id="loader_bg">
 <div id="loader">
  <img src="data:image/svg+xml,%3Csvg width='32' height='32' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid' class='uil-spin'%3E%3Cpath fill='none' class='bk' d='M0 0h100v100H0z'/%3E%3Cg transform='translate(84 50)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(45 -52.355 126.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.12s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(90 -17 67)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.25s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(135 -2.355 42.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.37s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(180 8 25)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.5s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-135 18.355 7.603)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.62s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-90 33 -17)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.75s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3Cg transform='rotate(-45 68.355 -76.397)'%3E%3Ccircle r='8'%3E%3Canimate attributeName='opacity' from='1' to='.1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3CanimateTransform attributeName='transform' type='scale' from='1.5' to='1' begin='0.87s' dur='1s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/g%3E%3C/svg%3E" width="128" height="128">
 </div>
</div>
<div id="overlay"></div>
<div id="dist_info"></div>
</body>
</html>
